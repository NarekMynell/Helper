 # Get Started
Job System-ը հնարավորությունա տալիս օգտագործոլ CPU-ի մյուս յադերները։ 
Job System-ը Burst Compiler-ի և [Entity Component System (ECS)](https://docs.unity3d.com/Packages/com.unity.entities@0.51/manual/index.html)-ի հետ միասին մեկ ավելի մեծ պրոեկտի՝ [Data Oriented Technology Stack (DOTS)](https://unity.com/dots)-ի մասա կազմում։
 [Հղում 1](https://www.raywenderlich.com/7880445-unity-job-system-and-burst-compiler-getting-started)


Այս ամենն օգտագործելու համար անհրաժեշտ են հետևյալ փեքիջները․
    * Jobs
    * Burst
    * Mathematics (նիզկաուռվնի օպտիմիզացիայի համար)
    
Job System-ում պետքա օգտագործել Unity-ի քլեքշները: Ինչու՞։ Սովորական քլեքշների դեպքում Job-ին չենք կարող այն սսիլկով փոխանցենք, քանի որ դա հեսքաանվտանգ չի։ Լուծում կլիներ քլեքշնն ամբողջական քոփի անել ու փոխանցել, սակայն դա մեծ ռեսուրս կպահանջեր, ու գլխավոր հոսքում չենջերը չէին երևա։ Դրա համար օգտագործվում են  Unity-ի քլեքշների Native-ները, որոնք օգտագործում են էսպես ասած ընդահնուր ռեֆերենս։
Job-ին ռեֆերենս թայփ (դրանց քլեքշներ) չենք կարող փոխանցել։





# Unity Collections
* **Unity.Collections** namespace
Այստեղի քլեքշները սկսվում են *Native* անունով և բավարարում են multithreading-ի [Անվտանգության Համակարգին](https://docs.unity3d.com/Manual/JobSystemSafetySystem.html)։ Native-ների վատը նայա, որ նրանք չեն կարող պարունակել Native անդամներ։ Օր՝ չենք կարող գրել ```NativeList<NativeList<T>>```: Native-ներն ունեն իրենց էկվովալենտները Unsafe-ների մեջ։ Իրականում իրենցից ներկայացնում են հենց Unsafe-ներն՝ ավաելցրած անվտանգության մի քանի ֆոկուզներ։
* **Unity.Collections.LowLevel.Unsafe** namespace
Այստեղի քլեքշները սկսվում են *Unsafe* անունով և չեն բավարաում վերոնշյալ անվտանության համակարգին:


# Jobs Types
* **IJob** Ստանդարտ ջոբա, որը կարող է զուգահեռ աշխատել մյուս ջոբորի հետ։ Օգտագործվումա մի քանի միմիանց հետ կապ չունեցող օպերացիաների համար
* **IJobParallelFor** все задания ParallelFor позволяют выполнять одну и ту же независимую операцию для каждого элемента собственного контейнера в течение фиксированного числа итераций. Unity автоматически разделит работу на куски определенного размера.
На практике количество заданий на самом деле намного меньше, чем одно задание на элемент в массиве, на каждое ядро ​​ЦП приходится одно задание, и каждое из них получает четное количество элементов для обработки. Поскольку некоторые рабочие завершают свою работу быстрее, чем другие, мы используем то, что называется ```work-stealing```, чтобы выровнять время, затрачиваемое на каждое ядро. Когда рабочий процесс завершил всю свою работу, он просматривает очереди других рабочих процессов и пытается обработать некоторые элементы, назначенные другому рабочему процессу.
* **IJobParallelForTransform**  тип задания, предназначенный для работы с Transform.



# Alocation
GC-ն չի կառավարում Unity-ի քլեքշները։ Դրանք պետքա կառավարել [ռուչնոյ](https://docs.unity3d.com/Packages/com.unity.collections@1.2/manual/allocation.html)

Գոյություն ունեն հետևյալ Alocator-ները
* **Temp** предназначен для выделений со сроком жизни один кадр или меньше, имеет самое быстрое распределение. Его нельзя использовать в системе заданий.
* **TempJob** предназначен для выделений со сроком жизни четыре кадра, предлагает более медленное выделение, чем Temp . Их используют на небольших работах.
* **Persistent** предлагает самое медленное выделение, но оно может длиться в течение всего времени существования программы. Этот тип распределения может использоваться для более длинных заданий.


# Steps
* **JobHandle.Complete** մեթոդով ավարտում ենք աշխատանքը։ Դա պետա անել որ մեմրիի ուտեչկա չլինի ու  որ նորից կարողանանք Job-ը կանչենք։


# Other
* **TransformAccessArray** 
Քանի որ ջոբսը ռեֆերենս թայփերը սփորթ չի անում, նշանակումա Transform տիպ չենք կարա փոխանցենք։ TransformAccessArray-ը լուծումա էտ հարցը
* Native կալեկցիայի էլեմենտի արժեքը փոխելու համար պետքա՝ (քանի որ ռեֆերենսով չեն աշխատում)
    ~~~
    MyStruct temp = myNativeArray[i];
    temp.memberVariable = 0;
    myNativeArray[i] = temp;
    ~~~
* Вызовите ```Scheduleзадание```, как только у вас появятся необходимые данные, и не вызывайте ```Complete```, пока вам не понадобятся результаты.
* Помните, что задания имеют доступ на чтение и запись к ```NativeContainer``` типам по умолчанию. При необходимости используйте ```[ReadOnly]``` атрибут для повышения производительности.
* В единстве ```Профайлер``` в окне маркер ```WaitForJobGroup``` в потоке управления указывает, что Unity ожидает завершения задания в рабочем потоке. Этот маркер может означать, что вы где-то ввели зависимость от данных, которую вы должны разрешить. Ищите ```JobHandle.Complete```, чтобы отследить, где у вас есть зависимости данных, которые заставляют поток управления ждать.
* Задания имеют функцию ```IJobExtensions.Run``` , которую можно использовать вместо ```Schedule``` для немедленного выполнения задания в потоке управления. Вы можете использовать это для целей отладки.