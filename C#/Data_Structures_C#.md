* [Տվյալների Կառուցվածքներ](#տվյալների-կառուցվածքներ)
    * [Ընդհանուր տվյալների կառուցվածքներ](#ընդհանուր-տվյալների-կառուցվածքներ)
        * [Set](#set)
        * [Map](#map)
        * [Ծառեր](#ծառեր)
            * [Binary Tree](#binary-tree)
            * [Red Black Tree](#red-black-tree)
            * [AVL Tree](#avl-tree)
            * BK tree
            * k-d tree
            * Ball tress
    * [Տվյալների կառուցվածքներ C#-ում](#տվյալների-կառուցվածքներ-c-ում)
        * [Array](#array)
        * [ArrayList](#arraylist)
        * [HashTable](#hashtable)
        * [List](#list)
        * [SortedList](#sortedlist)
        * [LinkedList](#linkedlist)
        * [Dictionary](#dictionary)
        * [SortedDictionary](#sorteddictionary)
* [Ալգորիթմներ](#ալգորիթմներ)
    * [Սորտավորման ալգորիթմներ](#սորտավորման-ալգորիթմներ)
        * [Bubble Sort](#bubble-sort)
        * [Selection Sort](#selection-sort)
        * [Insertion Sort](#insertion-sort)
        * [Marge Sort](#marge-sort)
        * [Quick Sort](#quick-sort)
    * [Որոնման ալգորիթմներ](#որոնման-ալգորիթմներ)


# Տվյալների կառուցվածքներ

## Ընդհանուր տվյալների կառուցվածքներ

### Set
Էլեմենտները չեն կրկնվում, հեշովա աշխատում, ուստի որոնման բարդությունը 1-ա։

### Map
Քի-Վելյուներովա աշխատում ու էլի հեշովա։

### Ծառեր

#### Binary Tree

#### Red Black Tree
* Ամեն բջիջն ունի լրացուցիչ մի բիթ, որի մեջ պահվումա կարմիր կամ սև։ Արմատը միշտ սևա, ոչ մի 2 իրար միացվսծ բջիջներ չեն կարող լինել կարմիր, տերևները միշտ սև են։
* Հարմարա ավելացման և հեռացման համար, սակայն ոչ որոնման։

#### AVL Tree
* Ամեն բջիջ պահումա լրացուցիչ 1 ամբողջ թիվ բալանսի մասին։
* Հարմարա որոնման համար սակայն ոչ ավելացման և հեռացման։

#### KD Tree
* Էլեմենտների քիերը իրենցից ներկայացնում են K հատ արժեքների հավաքածու։ Ծառը ամեն էլեմենտով տարածությունը բաժանումա կտորների։
* Օգտագործվումա ամենամոտ կետը գտնելու համար։
* Հարմարա մեծ չափանի տարածությունների համար։


## Տվյալների կառուցվածքներ C#-ում

### Array
* Գտնվումա - System
* Հիպումա ու խիստ տիպավորվածա․ այսինքն բոլոր էլեմենտները պետք է լինեն մեկ տիպի

### ArrayList
* Գտնվումա - System.Collection
* Գտնվումա հիպում ու անընդհատ հիշողությունա զբաղեցնում ինչպես ըրեյը։ Տարբերությունը ըրեյից նայա, որ խիստ տիպավորված չի ու բոլոր էլեմենտները object տիպի են, այսինքն մի օբյեկտի էլեմենտները կարող են ընդունել ցանկացած տիպ։ Տարբերությունա նաև այն, որ չափսերը դինամիկ փոփոխվող են։ Երբ հայտարարում ենք հատկացվումա 4 բայթ հիշողություն ու ամեն անգամ սպառվելուց հետո այն կրկնապատկվումա։ Դինամիզմի համար սկայն վճարում ենք պռաիզվաձիծելնստով, քանի որ ամեն երկարացման ժամանակ նոր հիշողությունա վերցվում ու եղածը քոփի անում։
* **Այն, ինչպես նաև System.Collection-ի մյուս կալեկցիաները ստեղծվել էին, երբ C#-ում դեռ չկաին ջեներիքները։ Ավելի լավա օգտագործել System.Collection․Generic-ի կալեկցիաները։**

### HashTable
* Գտնվումա - System.Collection
* Էլեմենտի որոնման բարդությունը - O(1)
* Այլ լեզուներում հայտնիա նաև Hash Map։ Ամեն քիի համար գեներացնումա հեշ ու ըստ էտ հեշի ինդեքսավորումա։ 

### List
* Գտնվումա - System.Collection․Generic
* ArrayList-ի համարժեքնա ջեներիքներում

### SortedList
* Գտնվումա - System.Collection․Generic
* Ներքին ստռուկտուռան մասիվա։ Մի մասիվ պահումա արժեքների համար, մի մասիվ քիերի համար։ Երբ նոր էլեմենտա ավելացվում BinarySearch ալգորիթմով գտնումա դրա տեղը մասիվում, ազատում էտ տեղն ու տեղադրում քիի արժեքը։
* Որոնման բարդւթյունը - O(log n)
* Ավելացման և հեռացման բարդւթյունը - O(n)
* Սրա լավը նայա, որ ինդեքսավորման հնարավորությունա տալիս

### LinkedList
* Գտնվումա - System.Collection․Generic
* Ամեն էլեմենտն իրենից նեկայացնումա թյուփլի տիպի մի բան, որի ձախ և աջ յաչեյկեքը համապատասխանաբար ձախ և աջ էլեմենտների ռեֆերենսներն են

### Dictionary
* Գտնվումա - System.Collection․Generic
* HashTable-ի համարժեքնա ջեներիքներում։ Տակից աշխատումա List-ի մեխանիզմն, այսինքն օգտագործումա զանգվածներ։ Սկզբնական ինիցիլիզացիայի ժամանակ տալիսա 3 օբյեկտի համար նախատեսված հիշողություն։ Երբ ազատ հիշողությունը վերջանումա, ստեղծումա նոր զանգված հինի երկարությունը բազմապատկելով 2-ով ու գտնելով արդյունքից մեծ կամ հավասար պարզ թիվը։ Եվ այդպես մինչև 7199369-ը, որից հետո պարզ թվի որոնումն արդեն ռուչնոյա կատարվում, ինչը ազդումա պռաիզվաձիծելնստի վրա, չհաշված ամեն անգմ նոր զանգված ստեղծելն ու արժեքները տեղափոխելը։
* Խիստ հորդորվումա իսկզբանե նշել երկարությունը։

### SortedDictionary
* Գտնվումա - System.Collection․Generic
* Այստեղ ռեալիզացիան կատարվումա ծառի մեթոդով, այլ ոչ թե հեշերի։
* Որոնման, ավելացման և հեռացման բարդւթյունը - O(log n)





<br><br><br>

# Ալգորիթմներ

## Սորտավորման ալգորիթմներ
<br>

<img style="float: left;" src="https://lamfo-unb.github.io/img/Sorting-algorithms/Complexity.png" height = "360"/>

<img style="float: left;" src="https://he-s3.s3.amazonaws.com/media/uploads/ece920b.png" height = "360"/>

<br clear="left"/>
<br>

### Bubble Sort
<img style="float: left;" src="https://camo.githubusercontent.com/4e8a95d4d21c217332eb200220a33aa883a1e163/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f636f6465636164656d792d636f6e74656e742f70726f6772616d732f7464642d6a732f61727469636c65732f427562626c65536f72742e676966"/>

    * Բարդությունը - O(n2)
    * Համեմատումա 2 հարևան էլեմենտներն ու սորտավորում։ Ամեն քայլ մեծագույն էլեմենտը կտանի վերջ։
    * Հարմար է օգտագործել, երբ դատան մասնակի արդեն իսկ սորտավորված է ( օր՝ [0, 2, 4, 3, 5, 6, 9, 8], օր՝ ֆեյսբուքում գրանցված օգտատերերի տարիքները )

<br clear="left"/>
<br>

### Selection Sort
<img style="float: left;"  src="https://miro.medium.com/max/1224/1*6StPgwLF96oEEYBeuJHxAQ.gif"  width = "320"/>

    * Բարդությունը - O(n2)
    * Ամեն անցման ժամանակ գտնում է ամենափոքր էլեմենտը և բերում սկիզբ։
    * Ամենադանդաղ ալգորիթմներիցա, սակայն հարմարա փոքր դատաների հետ աշխատելիս։

<br clear="left"/>
<br>

### Insertion Sort
<img style="float: left;" src="https://miro.medium.com/max/1012/1*JP-wURjwf4k23U2G3GNQDw.gif" width = "320"/>
    
    * Բարդությունը - O(n2)
    * Ամեն անցման ժամանակ էլեմենտը համեմատումա իր նախորդի հետ, եթե նախորդն ավելի մեծա, նախորդի արժեքը գրում ենք իր տեղում, իսկ իրեն մտապահում, կրկին համեմատում ենք նոր նախորդի հետ, եթե նոր նախորդը փոքրա իրենից, ապա իրեն տեղադրում ենք այդ տեղում։
    * Հարմար է փոքր դատաների դեպքում։ Ի տարբերություն Selection Sort-ի էստեղ պետք չի էլեմենտը համեմատել մնացած բոլոր էլեմենտների հետ, այլ պետք է համեմատել միայն իրեն նախորդողների հետ։

<br clear="left"/>
<br>

### Marge Sort
<img style="float: left;" src="https://cdn.devdojo.com/images/september2021/mergesort_intro.gif" width = "320"/>

    * Բարդությունը - O(n log(n))
    * Օգտագործվումա 2 ֆունկցիա։ Առաջին ֆունկցիան ռեկուրսիվ բաժանումա դատան 2 մասերի և այդ մասերը տալիս երկրորդ ֆունկցիային, որը կատարումա սորտավորումը։
    * Հարմար է մեծ դատաների հետ աշխատելիս։

<br clear="left"/>
<br>

### Quick Sort
<img style="float: left;" src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" width = "320"/>

    * Բարդությունը - O(n log(n))
    * Ընտրումա փիվոթ (սովորաբար վերջին կամ առաջին էլեմենտը) ու արժեքները դասավորում հետևյալ կերպ։ Պիվոթից ձախ իրենից փոքրերը, փիվոթից աջ՝ մեծերը։ Եվ այսպես ռեկուրսիվ կանչելով մինչև խմբերում չմնան մեկական էլեմենտներ։
    * Հարմար է աշխատել մեծ դատաների դեպքում։ Ծրագրավորման մեջ առավել կիրառելի սորտավորման ալգորիթմն է։

<br clear="left"/>
<br>

